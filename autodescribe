#!/bin/sh
# autodescribe - automatically extract comments from files
# Placed into the public domain by Dan Fandrich <dan@coneharvesters.com>
# See the file COPYING for details of how CC0 applies to this file.

# Print a shell-quoted version of the first argument
shquote() {
	echo "$1" | awk -v q="'" '{gsub(q, q "\\" q q, $0); printf "%s", q $0 q;}'
}

# Get comment from a compressed tar file
# Comment is taken from a man page file with name *.[0-9]
# or from a Linux Software Map entry
# BUG: tar will often create empty directories, or directories containing
# symbolic links matching *.[0-9] at least with GNU tar 1.11.2
# BUG: tar will extract all files if path ends in a number, e.g. playmidi-2.3/foo
comment_tgz () {
	COMMENT=$(tar -xOkzf - --wildcards \*.man \*.\[0-9\] 2> /dev/null < "$f" | lexgrog - | sed -e 's/^[^"]*"//' -e 's/"$//')
	if [ -z "$COMMENT" ] ; then
		COMMENT=$(tar -xOkzf - \*.lsm 2> /dev/null < "$f" | sed -n 's/^Title: *//p')
	fi
}

# Get comment from a .lzh file
# Comment must be stored as one line in a file called 'desc.sdi'
comment_lzh () {
	COMMENT=$(lha pq -- "$f" desc.sdi | head -3 | tr '\n' ' ' | sed -e 's/^[ 	]*//' -e 's/[ 	]*$//')
}

# Get comment from a .zip file
comment_zip () {
	if [ -n "$(unzip -zq -- "$f" dummy-file-to-eliminate-output)" ]; then
		COMMENT=$(unzip -zq -- "$f" dummy-file-to-eliminate-output | head -2 | tr '\n' ' ' | sed -e 's/^[ 	]*//' -e 's/[ 	]*$//')

	elif unzip -vqq -- "$f" desc.sdi > /dev/null ; then
		COMMENT=$(unzip -caq -- "$f" desc.sdi | head -3 | tr '\n' ' ' | sed -e 's/^[ 	]*//' -e 's/[ 	]*$//')
	fi
}

# Get comment from a .zoo file
comment_zoo () {
	COMMENT=$(zoo vc "$f" dummy-file-to-eliminate-output | \
		sed -n -e 's/^>> //p' | tr '\n' ' ')
	if [ -z "$COMMENT" ] && zoo vq "$f" desc.sdi > /dev/null ; then
		COMMENT=$(zoo xpq "$f" desc.sdi | head -3 | tr '\n' ' ' | sed -e 's/^[ 	]*//' -e 's/[ 	]*$//')
	fi
}

# Get comment from an RPM package
comment_rpm () {
	COMMENT=$(rpm -qp --queryformat '%{SUMMARY}' -- "$f")
}

# Get comment from a PostScript file
comment_ps () {
	COMMENT=$(sed -n 's/^%%Title: *//p' < "$f" | head -1)
	if [ -z "$COMMENT" ] ; then
		# Try for an alternate comment
		# Look for a comment beginning with one or more % followed by a space
		COMMENT=$(sed -n 's/^%%*  *//p' < "$f" | head -1)
	fi
}

# Get comment from a PostScript font file
comment_psfont () {
	COMMENT=$(sed -n 's/^\/FullName[ 	]*(\(.*\)).*$/\1/p' < "$f" | head -1)
	if [ -z "$COMMENT" ] ; then
        # Try for an alternate comment
		COMMENT=$(sed -n 's/^\/FontName[ 	]*\/\([^ 	]*\).*$/\1/p' < "$f" | head -1)
	fi
}

# Get comment from a news or mail file
comment_subject () {
	COMMENT=$(sed -n 's/^Subject: *//ip' < "$f" | head -1)
	if [ -z "$COMMENT" ] ; then
        # Try for an alternate comment
		COMMENT=$(sed -n 's/^Content-Description: *//ip' < "$f" | head -1)
	fi
}

# Get comment from a TIFF image
comment_tiff () {
	COMMENT=$(tiffinfo -- "$f" | sed -n -e 's/^ *ImageDescription: //p')
	if [ -z "$COMMENT" ] ; then
	# Try for alternate comments. ImageDescription can't be added as an
	# alternative here because tags are sorted numerically and it would come
	# after DocumentName, which is a less desirable tag to use if both exist.
      COMMENT=$(tiffinfo -- "$f" | sed -n -e 's/^ *\(DocumentName\|Artist\): //p' | tr '\n' ' ')
	fi
}

# Get comment from C source file
comment_c () {
	COMMENT=$(sed -n '/\/\*/,/\*\//{
			/\/\*/s/^.*\/\*[ 	]*//
			/\*\//s/.*\*\/[ 	]*//
			s/^[ 	*]*//
			s/\*\/ *$//
			s/[ 	]*$//
			p 
			}' < "$f" | head -3 | tr '\n' ' ' | sed -e 's/^[ 	]*//' -e 's/[ 	]*$//')
}

# Get comment from Pascal source file
comment_pascal () {
	COMMENT=$(sed -n '/(\*/,/\*)/{
			/(\*/s/^.*(\*//
			s/^[ 	*]*//
			s/[ 	]*$//
			p 
			}' < "$f" | head -3 | tr '\n' ' ' | sed -e 's/^[ 	]*//' -e 's/[ 	]*$//')
}

# Get comment from an assembly language file
comment_asm () {
	COMMENT=$(sed -n -e "/^[ 	]*\(\.\)\?title/{s/^[ 	]*\(\.\)\?title[ 	]*//;s/^['\"]*//;s/['\"]*$//;p}" < "$f")
}

# Get comment from a GIF image
comment_gif () {
	COMMENT=$(gifsicle --info -- "$f" | sed -n 's/^ *comment //p')
}

# Get comment from a JPEG JFIF image
comment_jpeg () {
	COMMENT=$(rdjpgcom < "$f")
	if [ -z "$COMMENT" ] ; then
		COMMENT=$(exif --ifd=0 --tag=ImageDescription -m -- "$f")
	fi
	if [ -z "$COMMENT" ] ; then
		COMMENT=$(exif --ifd=0 --tag=Artist -m -- "$f")
	fi
	if [ -z "$COMMENT" ] ; then
		COMMENT=$(exif --ifd=0 --tag=XP_Author -m -- "$f")
	fi
	if [ -z "$COMMENT" ] ; then
		COMMENT=$(exif --ifd=0 --tag=Copyright -m -- "$f")
	fi
	if [ -z "$COMMENT" ] ; then
		COMMENT=$(exif --ifd=EXIF --tag=UserComment -m -- "$f")
	fi
}

# Get comment from the first nonblank line of a text file
comment_first_line () {
	COMMENT=$(grep -v '^[[:space:]]*$' < "$f" | head -1)
}

# Get comment from a shell script file
comment_sh () {
	# delete #!/bin/sh line and blank comment lines
	# comment must be in the first 10 lines of the file
	COMMENT=$(sed -n -e '10,$d' -e '/^#\!/d' -e '/^#* *$/d' -e 's/^# *//p' < "$f" | head -1)
}

# Get comment from a Python source file
comment_py () {
	# delete #!/bin/sh line and blank comment lines
	# comment must be in the first 10 lines of the file
	COMMENT=$(sed -n -e '10,$d' -e '/^#\!/d' -e '/^#* *$/d' -e 's/^# *//p' -e "s/\(.\) *'''$/\1/" -e 's/\(.\) *"""$/\1/' -e "s/^''' *\(.\)/\1/p" -e 's/^""" *\(.\)/\1/p' -e "/^''' *$/{n;p}" -e '/^""" *$/{n;p}' < "$f" | head -1)
}

# Get comment from the HTML <title>
comment_html () {
	COMMENT=$(sed -n 's,^.*<title>\(.*\)</.*$,\1,ip' < "$f")
}

# Make comment from an XBM image
# Currently uses the embedded image name as the comment.
# Could extract image size here as well
comment_xbm () {
	COMMENT=$(sed -n 's/^.* \(.*\)_bits.*$/\1/p' < "$f")
}

# Make comment from an XPM image
# Currently uses the embedded image name as the comment.
# Could extract image size here as well
comment_xpm () {
	COMMENT=$(sed -n 's/^.*\* *\(.*\)_xpm.*$/\1/p' < "$f")
}

# Make comment from a pnm image
# The netpbm formats do not allow arbitrary metadata, so it's impossible to
# embed a comment in the file. Instead, use the file dimensions & colours as
# the comment.
comment_pnm () {
	COMMENT=$(pamfile -- "$f" | sed -n 's/^.*:	//p')
}


###########################

if [ $# -eq 0 ] ; then
	echo 'autodescribe ver. 2.1'
	echo 'Usage: autodescribe [-e program] [ -q ] [ -t type ] file1 [ file2 ... ]'
	echo 'Extracts comments from files'
	echo '  -e cmd   command to run once for each file with args: comment file'
	echo '             e.g. "setfattr -n user.xdg.comment -v"'
	echo '  -q         quiet output'
	echo '  -t type  where type is one of the following:'
	echo '             asm (assembly language source)'
	echo '             c (C source code)'
	echo '             first_line (first line of text file)'
	echo '             gif (GIF image)'
	echo '             html (HTML text)'
	echo '             jpeg (JPEG JFIF image)'
	echo '             lzh (lzh/lha archive with desc.sdi comment)'
	echo '             pascal (Pascal source code)'
	echo '             ps (PostScript source code)'
	echo '             py (Python source code)'
	echo '             psfont (PostScript font)'
	echo '             pnm (pbm/pgm/ppm/pam Portable Bitmap)'
	echo '             rpm (rpm package)'
	echo '             sh (shell script)'
	echo '             subject (news article or mail file)'
	echo '             tgz (compressed tar archive)'
	echo '             tiff (TIFF image)'
	echo '             xbm (X bitmap)'
	echo '             xpm (X pixmap)'
	echo '             zip (zip archive)'
	echo '             zoo (zoo archive)'
	exit 1
fi

if [ "$1" = "-e" ] ; then
	PROG="$2"
	shift
	shift
else
	PROG=
fi

if [ "$1" = "-q" ] ; then
	VERBOSE=0
	shift
else
	VERBOSE=1
fi

if [ "$1" = "-t" ] ; then
	SETTYPE="$2"
	shift
	shift
else
	SETTYPE=
fi

# Loop through files, commenting one at a time
for f in "$@" ; do
	COMMENT=""

	if ! [ -r "$f" ] ; then
		echo "$f": Not found 1>&2
		continue
	fi

	if [ -n "$SETTYPE" ] ; then
		TYPE="$SETTYPE"
	else
		case "$f" in
			*.c | *.h)
				TYPE=c
				;;
			*.asm | *.s)
				TYPE=asm
				;;
			*.gif)	TYPE=gif
				;;
			*.html | *.htm)
				TYPE=html
				;;
			*.jpeg | *.jpg)
				TYPE=jpeg
				;;
			*.lzh | *.lha)
				TYPE=lzh
				;;
			*.mbox | *.mbx | *.mbo | *.nws | *.msg)
				TYPE=subject
				;;
			*.pas | *.p)
				TYPE=pascal
				;;
			*.pbm | *.pgm | *.ppm | *.pnm | *.pam)
				TYPE=pnm
				;;
			*.pfa | *.gsf)
				TYPE=psfont
				;;
			*.rpm)
				TYPE=rpm
				;;
			*.sh)	TYPE=sh
				;;
			*.ps)	TYPE=ps
				;;
			*.py)	TYPE=py
				;;
			*.tar.gz | *.tar.Z | *.tar.z | *.tgz)
				TYPE=tgz
				;;
			*.tif | *.tiff)
				TYPE=tiff
				;;
			*.txt | *.asc)
				TYPE=first_line
				;;
			*.xbm)
				TYPE=xbm
				;;
			*.xpm)
				TYPE=xpm
				;;
			*.zip)
				TYPE=zip
				;;
			*.zoo)
				TYPE=zoo
				;;
			*)
				TYPE=""
				;;
		esac
	fi

	if [ -z "$TYPE" ] ; then
		echo "$f": Not a known file type 1>&2
	else
		# Call the right function to find the comment
		comment_"$TYPE"
	fi

	if [ -z "$COMMENT" ] ; then
		echo "$f": No comment found 1>&2
	else
		if [ "$VERBOSE" -eq 1 ] ; then
			shquote "$f"
			printf " "
			shquote "$COMMENT"
			echo ""
		fi
		if [ -n "$PROG" ]; then
			eval $PROG $(shquote "$COMMENT") $(shquote "$f")
		fi
	fi
done
exit 0
